h1. Rules-of-thumb for formatting code in CWB / CQP


h2. Brace style

* For blocks after control structures: %{color:red}I prefer this indentation style%
** opening braces are on the same line as the control structure that they go with
** closing braces are on a line of their own, aligned with the start of the control structure keyword
* For function definitions: %{color:red}not sure about opening braces, what do you like better?%
** opening brace on a line of its own, hard-left-aligned
** closing brace on a line of its own, hard-left-aligned

h2. Indenting

* Indent second half of a one-statement @if / for / while@ by 1 tab %{color:red}yes, because it's technically like a block enclosed in parentheses (so same indent)%
* Indent lines within braces by 1 tab
* Indent width: 2 spaces (or 8 spaces???) (with tabs or with sopaces???) %{color:red}*spaces please!* (most portable); I prefer 2-space identation, but would also accept 4-space%
* Spaces, not tab characters, are used for aligning comments at the _end_ of code lines %{color:red}yes, for portability reasons again%

h2. Function definitions

* the return type of the function goes on the same line as the function name %{color:red}used to be mixed, but I've come to prefer return type on separate line (stands out better)%
** _there are exceptions to this however????_
* parameters are declared - with types - in the brackets (i.e. ANSI-style) %{color:red}all C code should adhere to the ANSI C standard%
* if there are relatively few parameters they also go on the same line
* if there are many parameters: %{color:red}I've never been comfortable with _any_ layout; what do you think?%
** put the first on the same line as the function name
** put each subsequent parameter on a line of its own, using spaces to indent so they all begin at the same point as the first

h2. Function and object names

* data structure, enumeration etc. typedefs have names in CamelCase with an initial cap (the actual @struct@ names can be anything)
* functions have names in all-lowercase (except when referring to an object name that contains uppercase) with "words" separated by underscore
** "families" of functions, e.g. in a single module, share a @prefix_@ where possible
** _there are a massive heap of exceptions to this ????_
** %{color:red}families of functions with common prefix are usually stuff I added; the original code used completely unsystematic names, as you can see from the defines I added to @cl/cl.h@%
* global variables are named like functions ((except some don't, they use CamelCase instead)) %{color:red}I'm completely unsystematic myself; what do you suggest?%

h2. Global variables

* Global variables %{color:red}should be ;-)% declared in source files when %{color:red}they are local to the source file%
* Global variables are declared in header files when %{color:red} they are used by other source files or exported in the API%
* @extern@ statements for global variables go in the corresponding header file rather than being declared in every source file that uses the variable.


h2. API commenting

* Overall comments about what a function does, how to use it, etc., go immediately before the prototype in the header file
** %{color:red}ideally, these mini-docs should be made more systematic; do you know if there's an automatic documentation generator for C code? (like JavaDoc etc.)%
* If a function is not in the header file, then such comments go directly before the definition
** %{color:red}these are mostly random comments; should we strive for complete, systematic documentation here? inline or in a separate code overview file?%

h2. Boolean values

* _Not sure what the preferred usage is here_ %{color:red}not sure myself; I think it was mixed, but my code uses 0 and 1 directly and @int@ for Boolean variables (which I always took to be the C way)%
** ( {most of} CQP uses a char typedef to Boolean plus #defined True and False;
** {most of} CL uses ints with literal 0 or 1??????)